/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./choi-trie.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./choi-trie.js":
/*!**********************!*\
  !*** ./choi-trie.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n/**\n *\n * choi-trie; trie for choi (based on radix-trie)\n *\n * Author : jbear; JI-WOONG CHOI\n * Contact : http://jbear.co\n * Copyright @ jbear\n *\n**/\n\nvar ChoiTrie = exports.ChoiTrie = function () {\n    function ChoiTrie() {\n        var about = {\n            VERSION: '0.2.8',\n            AUTHOR: \"jbear\"\n        };\n\n        var T = this;\n\n        T.CACHING_COUNTING = 2;\n\n        T.node = function (_word, _what) {\n            var _C = \"\";\n            var _H = \"\";\n            var _O = [];\n            var _I = [];\n            var _CC = [];\n            console.log(_what);\n\n            if (_what) {\n                if (_word.length == 0) {\n                    _C += ';';\n                    _H += '1;';\n                } else {\n                    _C += _word[0];\n                    _H += _word.length + _word;\n                }\n                _CC.push(1);\n\n                if (_what.constructor === Array) {\n                    _I.push(_what);\n                } else {\n                    _I.push([]);\n                    _I[0].push(_what);\n                }\n                console.log(\"_what = \" + _what);\n                console.log(\"_what = \" + JSON.stringify(_what));\n            }\n            return {\n                \"C\": _C, // Caching(first characeters) are saved here. (C & O)\n                \"H\": _H, // Hash bucket (H & I)\n                \"O\": _O, // generic nOde \n                \"I\": _I, // result of retrIeval\n                \"CC\": _CC, // Caching Counting\n                \"length\": _I.length,\n                \"length_h\": _I.length,\n                \"select\": function select(_word) {\n                    if (this.C) {\n                        return this.select_c(_word) * -1;\n                    } else if (this.H) {\n                        return this.select_h(_word);\n                    }\n                    return 0;\n                },\n                \"select_c\": function select_c(_char) {\n                    for (var i = 0; i < this.C.length; i++) {\n                        if (_char[0] === this.C[i]) return i;\n                    }\n\n                    return -1;\n                },\n                \"add_C\": function add_C(_char) {\n                    var idx = this.select_c(_char);\n\n                    if (idx != -1) {\n                        this.cachingIt(idx);\n                        return idx;\n                    } else {\n                        this.C += _char;\n                        this.CC.push(1);\n                        return this.C.length - 1;\n                    }\n                },\n                /* ! 10, @ 10^2, # 10^3 ... */\n                \"add_H\": function add_H(_word, _what) {\n                    var h_idx = this.select_H(_word);\n                    console.log(\"add_H : h_idx = \" + h_idx + \" word = \" + _word + \", what \" + JSON.stringify(_what));\n                    if (h_idx == -1) {\n                        var word_length = _word.length;\n                        this.H += word_length + _word;\n                        h_idx = this.length_h;\n                        this.length_h++;\n                    }\n\n                    if (!this.I[h_idx]) {\n                        this.I[h_idx] = [];\n                    }\n\n                    console.log(\"add_H : h_idx = \" + h_idx + \", this.H = \" + JSON.stringify(this.H) + \",  this.I = \" + JSON.stringify(this.I));\n                    this.I[h_idx].push(_what);\n                },\n                \"add_O\": function add_O(_word, _what) {\n                    var c_idx = this.select_c(_word[0]);\n                    console.log(\"add_O : c_idx = \" + c_idx + \", this.O = \" + JSON.stringify(this.O));\n                    if (!this.O[c_idx]) this.O[c_idx] = {};\n\n                    var co = this.O[c_idx];\n                    var maximum_idx = 0;\n                    var maximum_key = null;\n                    for (var key in co) {\n                        var min_length = _word.length > key.length ? key.length : _word.length;\n                        for (var i = 0; i < min_length; i++) {\n                            console.log(\"add_O : _word = \" + _word + \" key = \" + key);\n                            if (key[i] == _word[i]) {\n                                if (maximum_key == null || maximum_idx <= i) {\n                                    maximum_idx = i;\n                                    maximum_key = key;\n                                }\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n\n                    console.log(\"add_O : _word = \" + _word + \", _what = \" + JSON.stringify(_what) + \" maximum_idx = \" + maximum_idx + \" maximum_key = \" + maximum_key);\n\n                    if (maximum_key) {\n                        if (maximum_key.length - 1 == maximum_idx) return maximum_key;else {\n                            var prefix = maximum_key.substr(0, maximum_idx + 1);\n                            var postfix = maximum_key.substr(maximum_idx + 1, maximum_key.length - maximum_idx);\n\n                            console.log(\"add_O : prefix = \" + prefix + \", postfix = \" + postfix);\n\n                            if (co[maximum_key].length_h == co[maximum_key].length) {\n                                console.log(\"Wondering : \" + JSON.stringify(co[maximum_key]));\n                                co[maximum_key].pushPostfixToH(postfix);\n                            } else {\n                                console.log(\"Wondering : diff : \" + JSON.stringify(co[maximum_key]));\n                                co[maximum_key].pushPostfix(postfix);\n                                co[maximum_key].moveAllH2O();\n                            }\n\n                            co[prefix] = co[maximum_key];\n                            delete co[maximum_key];\n\n                            console.log(\"add_O : co[prefix] = \" + JSON.stringify(co[prefix]));\n\n                            return prefix;\n                        }\n                    } else {\n                        console.log(\"add_O : PUSHED what = \" + _what);\n                        co[_word] = new T.node(\"\", _what);\n                        console.log(\"add_O : co[_word] = \" + JSON.stringify(co[_word]));\n                        return true;\n                    }\n                },\n                \"cachingIt\": function cachingIt(_idx) {\n                    this.CC[_idx]++;\n                },\n                \"moveH2O\": function moveH2O(_idx) {\n                    var word_idx = 0;\n                    var h_index = 0;\n\n                    var _char = this.C[_idx];\n                    var _what = this.I[_idx];\n\n                    var idx_counting = 0;\n                    for (var i = 0; i < this.CC.length; i++) {\n                        if (this.CC[i] > T.CACHING_COUNTING) {\n                            continue;\n                        } else {\n                            _what = this.I[idx_counting++];\n                            if (idx_counting == _idx) {\n                                _char = this.C[i];\n                            }\n                        }\n                    }\n\n                    console.log(\"moveH2O : this = \" + JSON.stringify(this) + \" this.CC = \" + JSON.stringify(this.CC));\n                    console.log(\"moveH2O : _idx = \" + _idx + \", _char = \" + _char + \", _what = \" + JSON.stringify(_what) + \" this.H = \" + this.H + \", this.O = \" + JSON.stringify(this.O));\n                    while (h_index < this.H.length) {\n                        var prefix = \"\";\n\n                        var h_length = Number.parseInt(this.H[h_index]);\n\n                        if (this.H[h_index + 1] != _char) {\n                            h_index += h_length + 1;\n                            console.log(\"moveH2O : h_index = \" + h_index + \", \" + this.H.substr(0, h_index) + \" in while\");\n                            word_idx++;\n                            continue;\n                        } else {\n                            var word = this.pop_h(word_idx);\n                            console.log(\"moveH2O : word = \" + word + \" in while\");\n                            this.I.splice(word_idx, 1);\n                            this.add_O(word, _what);\n                            break;\n                        }\n                    }\n\n                    console.log(\"moveH2O : _idx = \" + _idx + \" this.H = \" + this.H + \", this.O = \" + JSON.stringify(this.O));\n\n                    /* Caching Counting should be changed for H to O */\n                    if (this.CC[_idx] <= T.CACHING_COUNTING) this.CC[_idx] += T.CACHING_COUNTING;\n                },\n                \"moveAllH2O\": function moveAllH2O() {\n                    var h_index = 0;\n                    // move bucket to object.\n                    console.log(\"moveAllH2O : this.H = \" + JSON.stringify(this.H));\n                    console.log(\"moveAllH2O : this.O = \" + JSON.stringify(this.O));\n                    console.log(\"moveAllH2O : this.I = \" + JSON.stringify(this.I));\n                    while (h_index < this.H.length) {\n                        if (this.H[h_index + 1]) {\n                            var word = this.pop_h(0);\n                            var what = this.I[0];\n                            this.I.splice(0, 1);\n                            this.add_O(word, what);\n                        }\n                    }\n\n                    // H, I initialization.\n                    this.H = \"\";\n                    this.I = [];\n                    this.length_h = 0;\n\n                    console.log(\"moveAllH2O : this.H = \" + JSON.stringify(this.H));\n                    console.log(\"moveAllH2O : this.O = \" + JSON.stringify(this.O));\n                    console.log(\"moveAllH2O : this.I = \" + JSON.stringify(this.I));\n                    //Caching Counting Up Hardly\n                    console.log(\"moveAllH2O : this.CC = \" + JSON.stringify(this.CC) + \" T.CACHING_COUNTING = \" + T.CACHING_COUNTING);\n                    for (var i = 0; i < this.CC.length; i++) {\n                        if (this.CC[i] < T.CACHING_COUNTING) this.CC[i] += T.CACHING_COUNTING;\n                    }\n                },\n                \"select_H\": function select_H(_word) {\n                    var idx = 0;\n                    var bucket_idx = 0;\n                    var bucket = this.H;\n                    while (bucket_idx < bucket.length) {\n                        if (_word.length == bucket[bucket_idx]) {\n                            var isFound = true;\n                            var bucket_i = bucket_idx + 1;\n                            for (var i = 0; i < _word.length; i++, bucket_i++) {\n                                if (_word[i] != bucket[bucket_i]) {\n                                    isFound = false;\n                                    break;\n                                }\n                            }\n\n                            if (isFound) return idx;else {\n                                bucket_idx += _word.length + 1;\n                                console.log(\"select_H : bucket = \" + bucket + \", bucket_idx = \" + bucket_idx);\n                                idx++;\n                            }\n                        } else {\n                            bucket_idx += Number.parseInt(bucket[bucket_idx]) + 1;\n                            console.log(\"select_H : bucket = \" + bucket + \", bucket_idx = \" + bucket_idx);\n                            idx++;\n                        }\n                    }\n\n                    return -1;\n                },\n                \"get_h\": function get_h(_idx) {\n                    var h_idx = 0;\n                    var ret = 0;\n\n                    if (!this.H) return -1;\n\n                    while (h_idx < this.H.length) {\n                        if (_idx == ret) return this.H.substr(h_idx + 1, this.H[h_idx]);\n                        if (this.H[h_idx]) {\n                            h_idx += parseInt(this.H[h_idx]) + 1;\n                            ret++;\n                        } else return -1;\n                    }\n                    return -1;\n                },\n                \"pop_h\": function pop_h(_idx) {\n                    var h_idx = 0;\n                    var ret = 0;\n\n                    if (!this.H) return -1;\n\n                    while (h_idx < this.H.length) {\n                        if (_idx == ret) {\n                            var pop_front = this.H.substr(0, h_idx);\n                            var pop = this.H.substr(h_idx + 1, this.H[h_idx]);\n                            var pop_end = this.H.substr(h_idx + parseInt(this.H[h_idx]) + 1, this.H.length);\n                            this.H = pop_front + pop_end;\n                            //this.I.splice(_idx, 1);\n                            this.length_h--;\n                            return pop;\n                        }\n                        if (this.H[h_idx]) {\n                            h_idx += parseInt(this.H[h_idx]) + 1;\n                            ret++;\n                        } else return -1;\n                    }\n                    return -1;\n                },\n                \"pushPostfixToH\": function pushPostfixToH(_postfix) {\n                    if (this.length_h == this.length) {\n                        var h_idx = 0;\n                        var h_char_idx = 0;\n                        var new_H = \"\";\n                        while (h_idx < this.length_h) {\n                            var hashLength = parseInt(this.H[h_char_idx]);\n                            h_char_idx++;\n\n                            this.C = this.C.replace(this.H[h_char_idx], _postfix[0]);\n                            if (hashLength == 1) {\n                                if (this.H[h_char_idx] == ';') {\n                                    hashLength = _postfix.length;\n                                    new_H += hashLength + '' + _postfix;\n                                } else {\n                                    hashLength += _postfix.length;\n                                    new_H += hashLength + '' + _postfix + this.H[h_char_idx];\n                                }\n                            } else {\n                                var hash = this.H.substr(h_char_idx, hashLength);\n                                hashLength += _postfix.length;\n                                new_H += hashLength + '' + _postfix + hash;\n                                h_char_idx += hash.length;\n                            }\n\n                            h_char_idx++;\n                            h_idx++;\n                        }\n                        console.log(\"pushPostfix : this.C = \" + this.C + \" postfix = \" + _postfix + \" this.H = \" + this.H + \", new_H = \" + new_H);\n                        this.H = new_H;\n                    }\n                },\n                \"pushPostfix\": function pushPostfix(_postfix) {\n\n                    // Object Check\n                    var postfixObject = {};\n                    console.log(\"pushPostfix : this.O = \" + JSON.stringify(this.O));\n                    for (var i = 0; i < this.O.length; i++) {\n                        for (var key in this.O[i]) {\n                            console.log(\"pushPostfix : key = \" + key);\n                            if (key && key.length == 1 && key[0] == ';') this.O[i][_postfix] = this.O[i][key];else {\n                                this.O[i][_postfix + key] = this.O[i][key];\n                            }\n                            delete this.O[i][key];\n                        }\n                    }\n                    console.log(\"pushPostfix : this.O = \" + JSON.stringify(this.O));\n\n                    // C O\n                    // Caching\n                    this.C = _postfix[0];\n\n                    // Cache Counting Check\n                    var CC_SUM = 0;\n                    console.log(\"pushPostfix : this.CC = \" + JSON.stringify(this.CC));\n                    for (var i = 0; i < this.CC.length; i++) {\n                        CC_SUM += this.CC[i];\n                    }this.CC.length = 0; // INIT CC\n                    this.CC.push(CC_SUM);\n                    console.log(\"pushPostfix : this.CC = \" + JSON.stringify(this.CC));\n                },\n                \"removePrefix\": function removePrefix(_prefix) {\n                    if (this.length < this.BUCKET_START_POINT) {\n                        var h_idx = 0;\n                        this.H = this.H.split(\"\");\n\n                        while (h_idx < this.H.length) {\n                            var word_length = parseInt(this.H[h_idx]);\n                            if (word_length >= _prefix.length) {\n                                var isSamePrefix = true;\n                                for (var i = 0; i < _prefix.length; i++) {\n                                    if (this.H[h_idx + 1 + i] != _prefix[i]) {\n                                        isSamePrefix = false;\n                                    }\n                                }\n\n                                // Remove prefix\n                                if (isSamePrefix) {\n                                    this.H[h_idx] = word_length - _prefix.length;\n                                    for (var i = 1; i < _prefix.length; i++) {\n                                        delete this.H[h_idx + i];\n                                    }\n                                }\n                            }\n\n                            h_idx += word_length + 1;\n                        }\n                    } else {\n                        // removePrefix on C ..\n                    }\n                },\n                \"rank\": function rank(_word) {}\n            };\n        };\n\n        T.root = new this.node();\n    }\n\n    ChoiTrie.prototype = {\n        setRoot: function setRoot(_root) {\n            var T = this;\n            if (Object.keys(_root).length === 0 && _root.constructor === Object) {\n                T.root = Object.assign(_root, new T.node());\n            } else {\n                T.root = _root;\n            }\n\n            console.log(\"setRoot : T.root = \" + JSON.stringify(T.root));\n            console.log(T.root);\n        },\n        makeRoot: function makeRoot() {\n            var T = this;\n            var node = new T.node();\n            T.root = node;\n            return T.root;\n        },\n        add: function add(_word, _what) {\n            var self = this;\n            // For split word by ' '\n\n            var pushedWord = _word;\n            var spaceIdx = -1;\n            do {\n                self.addInternal(self.root, pushedWord, _what);\n                spaceIdx = pushedWord.indexOf(' ');\n\n                if (spaceIdx == -1) break;\n\n                pushedWord = pushedWord.substr(spaceIdx + 1, _word.length);\n            } while (pushedWord);\n        },\n        addInternal: function addInternal(_root, _word, _what) {\n            /* \n               addInternal Process\n               1) Character Caching check & Word Length Check ( Caching Condition : CACHING_COUNTING > 3, Length Condition : > 9 )\n               2) if word's cache counting is same with CACHING_COUNTING, moveH2O\n               3) if word is satisfied with the caching counting, add O\n               4) if word is not satisfied with that condition, add H\n            */\n            console.log(\"addInternal : function start : _word = \" + _word);\n            var self = this;\n            var current = _root;\n\n            // 1) Character Caching check\n            var c_idx = -1;\n            if (!_word) {\n                _word = \";\";\n                c_idx = current.select_c(';');\n                if (c_idx == -1) current.C += _word;\n            } else {\n                c_idx = current.add_C(_word[0]);\n            }\n            // 2) moveH2O\n            if (current.CC[c_idx] == self.CACHING_COUNTING) {\n                console.log(\"2) moveH2O\");\n                current.moveH2O(c_idx);\n            }\n            // 3) add O\n            if (current.CC[c_idx] >= self.CACHING_COUNTING || _word.length > 9) {\n                // Cache Counting Up Hardly\n                if (current.CC[c_idx] < self.CACHING_COUNTING) current.CC[c_idx] = self.CACHING_COUNTING + 1;\n\n                console.log(\"3) add O word = \" + _word + \", _what = \" + JSON.stringify(_what));\n                var result = current.add_O(_word, _what);\n\n                if (result != true) {\n                    var _obj = current.O[c_idx][result];\n                    console.log(\"result : \" + result + \", current : \" + JSON.stringify(current) + \", _obj : \" + JSON.stringify(_obj));\n\n                    return self.addInternal(_obj, _word.substr(result.length, _word.length), _what);\n                } else {\n                    current.length++;\n                }\n            }\n            // 4) Add Hash Bucket\n            else {\n                    console.log(\"4) add Hash Bucket\");\n                    current.add_H(_word, _what);\n                    current.length++;\n                } // Bucket to Characters\n\n            console.log(\"----------------ROOT--------------\");\n            console.log(self.root);\n        },\n        search: function search(_query) {\n            /*\n              Search Process for CHOI-TRIE\n              1) find C\n              2) Check CC\n              3) if word's cache counting is more than CACHING_COUNTING, find O.\n              4) if word's cache counting is less than CACHING_COUNTING, find H.              \n             */\n\n            var self = this;\n            var current = self.root;\n            var queryResult = [];\n            var query_idx = 0;\n            var prefix = null;\n            var found_check = false;\n            var query_instance = _query;\n            var query_instance_length = query_instance.length;\n\n            /*\n              Exact Prefix Matching implementation\n            */\n            var max_co = null;\n            var max_co_length = 0;\n            var c_idx = null;\n            var current_depth = 0;\n            current.select_c(query_instance[0]);\n\n            // 1) C check\n            while ((c_idx = current.select_c(query_instance[0])) != -1) {\n                console.log(\"search : query_instance : \" + query_instance);\n                console.log(current);\n                max_co = null;\n                max_co_length = 0;\n\n                // 2) CC Check\n                // 3) Find O\n                if (current.CC[c_idx] >= self.CACHING_COUNTING) {\n                    var co = current.O[c_idx];\n                    var co_idx = 0;\n\n                    console.log(co);\n                    max_co_length = 1;\n                    for (var key in co) {\n                        var min_length = key.length > query_instance.length ? query_instance.length : key.length;\n                        if (min_length == 1) {\n                            max_co = co[key];\n                            break;\n                        }\n\n                        var comp_idx = 1;\n                        var key_idx = 0;\n\n                        console.log(\"search : co = \" + JSON.stringify(co) + \", min_length = \" + min_length);\n                        for (; comp_idx < min_length; comp_idx++) {\n                            if (query_instance[comp_idx] == key[comp_idx]) {\n                                if (max_co_length < comp_idx + 1) {\n                                    max_co = co[key];\n                                    max_co_length = comp_idx + 1;\n                                }\n                                console.log(\"search : max_co = \" + JSON.stringify(max_co) + \", comp_idx = \" + comp_idx);\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n\n                    console.log(\"max_co_length = \" + max_co_length + \", comp_idx = \" + comp_idx);\n\n                    // Totally same\n                    if (max_co) {\n                        current = max_co;\n                        current_depth++;\n\n                        if (max_co_length == min_length) {\n                            query_instance = query_instance.substr(min_length, query_instance.length);\n                            if (query_instance.length == 0) {\n                                query_instance = \";\";\n                            }\n                            query_idx = 0;\n                            console.log(\"search : max_co_length == comp_idx\");\n                            console.log(current);\n                        }\n                    } else break;\n                }\n                // 4) Find H\n                else {\n                        var h_idx = current.select_H(query_instance);\n                        if (h_idx >= 0) {\n                            // for(var i = 0; i < current.I[h_idx].length; i++) {\n                            queryResult.push(current.I[h_idx]);\n                            // }\n                        } else {\n                            console.log(\"There is no result.\");\n                        }\n                        break;\n                    }\n            }\n\n            console.log(\"full search start!\");\n            console.log(current);\n\n            // if query has already found, finish.\n            if (queryResult.length > 0 || current_depth == 0) return queryResult;\n\n            // Now Full Search!\n            var fullQueue = [];\n            var fullQueueIdx = 0;\n            fullQueue.push(current);\n            while (fullQueue.length != fullQueueIdx) {\n                current = fullQueue[fullQueueIdx];\n                if (!current) break;\n                // H pushed\n                if (current.I) {\n                    current.I.some(function (_data) {\n                        queryResult.push(_data);\n                    });\n                }\n\n                // O Pushed\n                if (current.C) {\n                    for (var c_idx = 0; c_idx < current.C.length; c_idx++) {\n                        if (current.CC[c_idx] >= self.CACHING_COUNTING) {\n                            for (var _key in current.O[c_idx]) {\n                                fullQueue.push(current.O[c_idx][_key]);\n                            }\n                        }\n                    }\n                }\n                fullQueueIdx++;\n            }\n\n            console.log(\"RESULT\");\n            console.log(_query);\n            console.log(queryResult);\n\n            return queryResult;\n        } // end of search function\n    };\n\n    return ChoiTrie;\n}();\n\n//# sourceURL=webpack:///./choi-trie.js?");

/***/ })

/******/ });